package github

// Code generated by jsonapi. DO NOT EDIT.
// Source: github.com/pentops/o5-aws-tool/libo5/j5/registry/github/v1/github

import (
	context "context"
	json "encoding/json"
	errors "errors"
	list "github.com/pentops/o5-aws-tool/libo5/j5/list/v1/list"
	state "github.com/pentops/o5-aws-tool/libo5/psm/state/v1/state"
	url "net/url"
	strings "strings"
)

type Requester interface {
	Request(ctx context.Context, method string, path string, body interface{}, response interface{}) error
}

// RepoQueryService
type RepoQueryService struct {
	Requester
}

func NewRepoQueryService(requester Requester) *RepoQueryService {
	return &RepoQueryService{
		Requester: requester,
	}
}

func (s RepoQueryService) GetRepo(ctx context.Context, req *GetRepoRequest) (*GetRepoResponse, error) {
	pathParts := make([]string, 8)
	pathParts[0] = ""
	pathParts[1] = "registry"
	pathParts[2] = "github"
	pathParts[3] = "v1"
	pathParts[4] = "q"
	pathParts[5] = "repo"
	if req.Owner == "" {
		return nil, errors.New("required field \"Owner\" not set")
	}
	pathParts[6] = req.Owner
	if req.Name == "" {
		return nil, errors.New("required field \"Name\" not set")
	}
	pathParts[7] = req.Name
	path := strings.Join(pathParts, "/")
	if query, err := req.QueryParameters(); err != nil {
		return nil, err
	} else if len(query) > 0 {
		path += "?" + query.Encode()
	}
	resp := &GetRepoResponse{}
	err := s.Request(ctx, "GET", path, req, resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s RepoQueryService) ListRepos(ctx context.Context, req *ListReposRequest) (*ListReposResponse, error) {
	pathParts := make([]string, 6)
	pathParts[0] = ""
	pathParts[1] = "registry"
	pathParts[2] = "github"
	pathParts[3] = "v1"
	pathParts[4] = "q"
	pathParts[5] = "repo"
	path := strings.Join(pathParts, "/")
	if query, err := req.QueryParameters(); err != nil {
		return nil, err
	} else if len(query) > 0 {
		path += "?" + query.Encode()
	}
	resp := &ListReposResponse{}
	err := s.Request(ctx, "GET", path, req, resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s RepoQueryService) ListRepoEvents(ctx context.Context, req *ListRepoEventsRequest) (*ListRepoEventsResponse, error) {
	pathParts := make([]string, 9)
	pathParts[0] = ""
	pathParts[1] = "registry"
	pathParts[2] = "github"
	pathParts[3] = "v1"
	pathParts[4] = "q"
	pathParts[5] = "repo"
	if req.Owner == "" {
		return nil, errors.New("required field \"Owner\" not set")
	}
	pathParts[6] = req.Owner
	if req.Name == "" {
		return nil, errors.New("required field \"Name\" not set")
	}
	pathParts[7] = req.Name
	pathParts[8] = "events"
	path := strings.Join(pathParts, "/")
	if query, err := req.QueryParameters(); err != nil {
		return nil, err
	} else if len(query) > 0 {
		path += "?" + query.Encode()
	}
	resp := &ListRepoEventsResponse{}
	err := s.Request(ctx, "GET", path, req, resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// RepoCommandService
type RepoCommandService struct {
	Requester
}

func NewRepoCommandService(requester Requester) *RepoCommandService {
	return &RepoCommandService{
		Requester: requester,
	}
}

func (s RepoCommandService) ConfigureRepo(ctx context.Context, req *ConfigureRepoRequest) (*ConfigureRepoResponse, error) {
	pathParts := make([]string, 9)
	pathParts[0] = ""
	pathParts[1] = "registry"
	pathParts[2] = "github"
	pathParts[3] = "v1"
	pathParts[4] = "c"
	pathParts[5] = "repo"
	if req.Owner == "" {
		return nil, errors.New("required field \"Owner\" not set")
	}
	pathParts[6] = req.Owner
	if req.Name == "" {
		return nil, errors.New("required field \"Name\" not set")
	}
	pathParts[7] = req.Name
	pathParts[8] = "configure"
	path := strings.Join(pathParts, "/")
	resp := &ConfigureRepoResponse{}
	err := s.Request(ctx, "POST", path, req, resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s RepoCommandService) Trigger(ctx context.Context, req *TriggerRequest) (*TriggerResponse, error) {
	pathParts := make([]string, 9)
	pathParts[0] = ""
	pathParts[1] = "registry"
	pathParts[2] = "github"
	pathParts[3] = "v1"
	pathParts[4] = "c"
	pathParts[5] = "repo"
	if req.Owner == "" {
		return nil, errors.New("required field \"Owner\" not set")
	}
	pathParts[6] = req.Owner
	if req.Repo == "" {
		return nil, errors.New("required field \"Repo\" not set")
	}
	pathParts[7] = req.Repo
	pathParts[8] = "trigger"
	path := strings.Join(pathParts, "/")
	resp := &TriggerResponse{}
	err := s.Request(ctx, "POST", path, req, resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ListReposResponse
type ListReposResponse struct {
	Repos []*RepoState       `json:"repos,omitempty"`
	Page  *list.PageResponse `json:"page,omitempty"`
}

func (s ListReposResponse) GetPageToken() *string {
	if s.Page == nil {
		return nil
	}
	return s.Page.NextToken
}

func (s ListReposResponse) GetItems() []*RepoState {
	return s.Repos
}

// ListRepoEventsResponse
type ListRepoEventsResponse struct {
	Events []*RepoEvent       `json:"events,omitempty"`
	Page   *list.PageResponse `json:"page,omitempty"`
}

func (s ListRepoEventsResponse) GetPageToken() *string {
	if s.Page == nil {
		return nil
	}
	return s.Page.NextToken
}

func (s ListRepoEventsResponse) GetItems() []*RepoEvent {
	return s.Events
}

// RepoStateData Proto: RepoStateData
type RepoStateData struct {
	ChecksEnabled bool      `json:"checksEnabled"`
	Branches      []*Branch `json:"branches,omitempty"`
}

// GetRepoResponse
type GetRepoResponse struct {
	Repo *RepoState `json:"repo,omitempty"`
}

// ListRepoEventsRequest
type ListRepoEventsRequest struct {
	Owner string             `json:"-" path:"owner"`
	Name  string             `json:"-" path:"name"`
	Page  *list.PageRequest  `json:"-" query:"page"`
	Query *list.QueryRequest `json:"-" query:"query"`
}

func (s *ListRepoEventsRequest) SetPageToken(pageToken string) {
	if s.Page == nil {
		s.Page = &list.PageRequest{}
	}
	s.Page.Token = &pageToken
}

func (s ListRepoEventsRequest) QueryParameters() (url.Values, error) {
	values := url.Values{}
	if s.Page != nil {
		bb, err := json.Marshal(s.Page)
		if err != nil {
			return nil, err
		}
		values.Set("page", string(bb))
	}
	if s.Query != nil {
		bb, err := json.Marshal(s.Query)
		if err != nil {
			return nil, err
		}
		values.Set("query", string(bb))
	}
	return values, nil
}

// TriggerResponse
type TriggerResponse struct {
}

// Branch Proto: Branch
type Branch struct {
	BranchName    string              `json:"branchName"`
	DeployTargets []*DeployTargetType `json:"deployTargets"`
}

// RepoEventType Proto Message: RepoEventType
type RepoEventType struct {
	J5TypeKey       string                         `json:"!type,omitempty"`
	Configure       *RepoEventType_Configure       `json:"configure,omitempty"`
	ConfigureBranch *RepoEventType_ConfigureBranch `json:"configureBranch,omitempty"`
	RemoveBranch    *RepoEventType_RemoveBranch    `json:"removeBranch,omitempty"`
}

func (s RepoEventType) OneofKey() string {
	if s.Configure != nil {
		return "configure"
	}
	if s.ConfigureBranch != nil {
		return "configureBranch"
	}
	if s.RemoveBranch != nil {
		return "removeBranch"
	}
	return ""
}

func (s RepoEventType) Type() interface{} {
	if s.Configure != nil {
		return s.Configure
	}
	if s.ConfigureBranch != nil {
		return s.ConfigureBranch
	}
	if s.RemoveBranch != nil {
		return s.RemoveBranch
	}
	return nil
}

// RepoKeys Proto: RepoKeys
type RepoKeys struct {
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

// RepoEvent Proto: RepoEvent
type RepoEvent struct {
	Metadata *state.EventMetadata `json:"metadata"`
	Keys     *RepoKeys            `json:"keys"`
	Event    *RepoEventType       `json:"event"`
}

// GetRepoRequest
type GetRepoRequest struct {
	Owner string `json:"-" path:"owner"`
	Name  string `json:"-" path:"name"`
}

func (s GetRepoRequest) QueryParameters() (url.Values, error) {
	values := url.Values{}
	return values, nil
}

// ListReposRequest
type ListReposRequest struct {
	Page  *list.PageRequest  `json:"-" query:"page"`
	Query *list.QueryRequest `json:"-" query:"query"`
}

func (s *ListReposRequest) SetPageToken(pageToken string) {
	if s.Page == nil {
		s.Page = &list.PageRequest{}
	}
	s.Page.Token = &pageToken
}

func (s ListReposRequest) QueryParameters() (url.Values, error) {
	values := url.Values{}
	if s.Page != nil {
		bb, err := json.Marshal(s.Page)
		if err != nil {
			return nil, err
		}
		values.Set("page", string(bb))
	}
	if s.Query != nil {
		bb, err := json.Marshal(s.Query)
		if err != nil {
			return nil, err
		}
		values.Set("query", string(bb))
	}
	return values, nil
}

// ConfigureRepoRequest
type ConfigureRepoRequest struct {
	Config *RepoEventType_Configure `json:"config,omitempty"`
	Owner  string                   `path:"owner" json:"-"`
	Name   string                   `json:"-" path:"name"`
}

// ConfigureRepoResponse
type ConfigureRepoResponse struct {
	Repo *RepoState `json:"repo,omitempty"`
}

// DeployTargetType_O5Build Proto: DeployTargetType_O5Build
type DeployTargetType_O5Build struct {
	Environment string `json:"environment,omitempty"`
}

// RepoState Proto: RepoState
type RepoState struct {
	Metadata *state.StateMetadata `json:"metadata"`
	Keys     *RepoKeys            `json:"keys"`
	Status   string               `json:"status,omitempty"`
	Data     *RepoStateData       `json:"data,omitempty"`
}

// TriggerRequest
type TriggerRequest struct {
	Commit string            `json:"commit,omitempty"`
	Target *DeployTargetType `json:"target,omitempty"`
	Owner  string            `json:"-" path:"owner"`
	Repo   string            `json:"-" path:"repo"`
}

// RepoEventType_Configure Proto: RepoEventType_Configure
type RepoEventType_Configure struct {
	ChecksEnabled bool      `json:"checksEnabled"`
	Merge         bool      `json:"merge"`
	Branches      []*Branch `json:"branches"`
}

// RepoEventType_ConfigureBranch Proto: RepoEventType_ConfigureBranch
type RepoEventType_ConfigureBranch struct {
	Branch *Branch `json:"branch"`
}

// RepoEventType_RemoveBranch Proto: RepoEventType_RemoveBranch
type RepoEventType_RemoveBranch struct {
	BranchName string `json:"branchName"`
}

// DeployTargetType_J5Build Proto: DeployTargetType_J5Build
type DeployTargetType_J5Build struct {
}

// DeployTargetType Proto Message: DeployTargetType
type DeployTargetType struct {
	J5TypeKey string                    `json:"!type,omitempty"`
	J5Build   *DeployTargetType_J5Build `json:"j5Build,omitempty"`
	O5Build   *DeployTargetType_O5Build `json:"o5Build,omitempty"`
}

func (s DeployTargetType) OneofKey() string {
	if s.J5Build != nil {
		return "j5Build"
	}
	if s.O5Build != nil {
		return "o5Build"
	}
	return ""
}

func (s DeployTargetType) Type() interface{} {
	if s.J5Build != nil {
		return s.J5Build
	}
	if s.O5Build != nil {
		return s.O5Build
	}
	return nil
}

// CombinedClient
type CombinedClient struct {
	*RepoQueryService
	*RepoCommandService
}

func NewCombinedClient(requester Requester) *CombinedClient {
	return &CombinedClient{
		RepoQueryService:   NewRepoQueryService(requester),
		RepoCommandService: NewRepoCommandService(requester),
	}
}
